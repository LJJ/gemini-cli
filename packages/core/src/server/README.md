# Gemini CLI API Server 架构

## 设计原则

本服务器严格按照 SOLID 设计原则进行重构，确保代码的可维护性、可扩展性和可测试性。

## 架构概览

```
packages/core/src/server/
├── ServerConfig.ts      # 服务器配置和中间件
├── GeminiService.ts     # Gemini AI 服务
├── FileService.ts       # 文件操作服务
├── CommandService.ts    # 命令执行服务
└── README.md           # 架构文档
```

## 职责分离

### 1. ServerConfig.ts - 服务器配置
**职责**: 服务器基础配置和中间件设置
- Express 应用初始化
- CORS 配置
- 请求日志中间件
- 错误处理中间件
- 端口管理

### 2. GeminiService.ts - AI 服务
**职责**: Gemini AI 客户端管理和聊天处理
- Gemini 客户端初始化
- 聊天消息处理
- 流式响应处理
- 工具调用管理
- 工具确认处理

### 3. FileService.ts - 文件操作服务
**职责**: 文件系统操作
- 目录列表
- 文件读取
- 文件写入
- 错误处理

### 4. CommandService.ts - 命令执行服务
**职责**: 系统命令执行
- Shell 命令执行
- 工作目录管理
- 执行结果处理
- 错误处理

## SOLID 原则应用

### 单一职责原则 (SRP)
✅ 每个服务类只负责一个特定领域
- `ServerConfig`: 服务器配置
- `GeminiService`: AI 交互
- `FileService`: 文件操作
- `CommandService`: 命令执行

### 开闭原则 (OCP)
✅ 对扩展开放，对修改封闭
- 新功能可以通过添加新的服务类实现
- 现有服务类不需要修改即可扩展

### 里氏替换原则 (LSP)
✅ 子类可以替换父类
- 所有服务类都遵循相同的接口模式
- 可以轻松替换实现而不影响其他组件

### 接口隔离原则 (ISP)
✅ 客户端不应该依赖它不需要的接口
- 每个服务类提供特定功能的接口
- 避免胖接口和强制依赖

### 依赖倒置原则 (DIP)
✅ 高层模块不依赖低层模块
- `APIServer` 依赖抽象的服务接口
- 通过依赖注入解耦

## 扩展指南

### 添加新的服务
1. 在 `server/` 目录下创建新的服务类
2. 实现服务方法
3. 在 `APIServer` 中注入新服务
4. 添加相应的路由

### 添加新的路由
1. 在相应的服务类中添加处理方法
2. 在 `APIServer.setupRoutes()` 中注册路由
3. 确保错误处理

### 测试策略
- 单元测试：每个服务类独立测试
- 集成测试：服务间交互测试
- 端到端测试：完整 API 流程测试

## 性能优化

- 服务类采用单例模式
- 异步处理避免阻塞
- 错误处理确保稳定性
- 日志记录便于调试

## 安全考虑

- 输入验证和清理
- 文件路径安全检查
- 命令执行权限控制
- API 访问控制 